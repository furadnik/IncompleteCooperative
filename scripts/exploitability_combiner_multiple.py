#!/usr/bin/env python3
"""A script that combines exploitabilities of different runs into one file.

Usage:
    ./scripts/exploitability_combiner.py <starting-path>
"""
import json
import os
import sys
from argparse import ArgumentParser, Namespace
from pathlib import Path
from typing import Any

import matplotlib as mpl  # type: ignore
import matplotlib.pyplot as plt  # type: ignore
import numpy as np
import scipy

from incomplete_cooperative.run.save import Output
from scripts.find_data_jsons import find_data_jsons
from scripts.plot_base import (COLOR_VALUES, EXPLOITABILITY, NAME_MAP,
                               filter_func)

parser = ArgumentParser(description="Combine exploitabilities of different runs into one file.")
parser.add_argument("--path", type=Path, help="Path to the directory containing the data files.", default=Path("."))
parser.add_argument("--title", type=str, help="Title of the plot.", default="Combined Exploitabilities")
parser.add_argument("--name_filter", type=str, help="Filter for the names of the runs.", nargs="*")
parser.add_argument("--color_by", type=str, help="Color by which attribute.", default=None)

mpl.use("TkAgg")


DEFALUT_COLOR = list(COLOR_VALUES.values())[0]
COMPARE_TO = os.getenv("COMPARE_TO")
COMPARE_TO_NAME = NAME_MAP.get(COMPARE_TO)
KNOWN_COLORS = {}

COLORS = ["blue", "orange", "green", "red", "purple", "brown", "pink", "gray",
          "olive", "cyan", "magenta", "yellow", "lime", "teal", "navy", "maroon",
          "coral", "salmon", "khaki", "gold", "plum", "lavender"
          ]

STYLES = ["-", "--", "-.", ":", "solid", "dashed", "dashdot", "dotted"]
COLOR = COLORS[0]
STYLE = STYLES[0]


def add_to_plt(data: np.ndarray, name: str, color: Any | None) -> Any:
    """Add data drawing to plot."""
    if color is None:
        global COLOR
        color = COLOR
        COLOR = COLORS[(COLORS.index(COLOR) + 1) % len(COLORS)]
    global STYLE
    style = STYLE
    STYLE = STYLES[(STYLES.index(STYLE) + 1) % len(STYLES)]
    data_length = data.shape[0]
    mean = np.mean(data, 1)
    stde = scipy.stats.sem(data, 1)
    line = plt.plot(
        range(data_length), mean, color=color, zorder=4, label=name, linestyle=style)[0]
    plt.fill_between(
        range(data_length), mean + stde, mean - stde, color=color, zorder=3, alpha=0.3)
    return line


def apply_compare_to(datas: np.ndarray, codes: np.ndarray) -> np.ndarray:
    """Apply a 'compare to' view to the data."""
    assert COMPARE_TO is not None
    assert COMPARE_TO in codes
    compared_data = next(data for data, code in zip(datas, codes) if code == COMPARE_TO)
    assert all(data.shape[0] == compared_data.shape[0] for data in datas)

    mean = np.mean(compared_data, 1)
    nonzero = mean > 0
    return [data[nonzero] / mean[nonzero][:, None] for data in datas]


def get_colors(color_criteria: list[Any] | None, num_colors: int) -> list[Any]:
    """Get colors based on the criteria."""
    if color_criteria is None:
        return [None] * num_colors

    colors = []
    global KNOWN_COLORS
    for criterium in color_criteria:
        if criterium not in KNOWN_COLORS:
            global COLOR
            color = COLOR
            COLOR = COLORS[(COLORS.index(COLOR) + 1) % len(COLORS)]
            KNOWN_COLORS[criterium] = color
        else:
            color = KNOWN_COLORS[criterium]
        colors.append(color)
    return colors


def draw_combined_graph(codes_outputs: list[tuple[str, Output]], output_path: Path, title: str, pre_name: str, color_by: str | None) -> None:
    """Draw data into a combined graph."""
    # perform sorting by name
    names_codes_outputs = sorted((NAME_MAP.get(code, code), code, output) for code, output in codes_outputs)
    names = [name for name, _, _ in names_codes_outputs]
    codes = [code for _, code, _ in names_codes_outputs]
    outputs = [output for _, _, output in names_codes_outputs]
    datas = [output.data for output in outputs]

    color_criteria = None
    if color_by is not None:
        color_criteria = [vars(output.parsed_args)[color_by] for output in outputs]

    if COMPARE_TO:
        datas = apply_compare_to(datas, codes)

    colors = get_colors(color_criteria, len(codes))
    lines = [add_to_plt(data, pre_name + ":" + name, color)
             for name, data, code, color in zip(names, datas, codes, colors)
             if code != COMPARE_TO]
    plt.legend(bbox_to_anchor=(1.05, 1),
               loc='upper left', borderaxespad=0.)
    plt.title(title, family="monospace")


def main(args: Namespace) -> None:
    """Run the script."""
    path = args.path
    title = args.title
    name_filters = args.name_filter or []
    print(name_filters)

    # plot setup
    plt.grid(zorder=-1, alpha=.3)
    # plt.ylim(bottom=0)
    # plt.xlim((0, maximum_episode_length))

    for data in find_data_jsons(path):
        save_path = data.parent / "combined_exploitabilities.pdf"
        name = data.parent.resolve().name
        if any(name_filter not in name for name_filter in name_filters):
            continue
        with data.open("r") as f:
            outputs_raw = json.load(f)

        # a tuple (name, exploitabilities) of all runs (possibly filtered by the specified names in arg 3)
        codes_outputs = [(code, Output.from_json(raw_data))
                         for code, raw_data in outputs_raw.items()]
        print(*(code for code, _ in codes_outputs))
        draw_combined_graph(codes_outputs, save_path, title, name, args.color_by)

    plt.xlabel("Budget")
    plt.ylabel(EXPLOITABILITY)
    plt.savefig(f"combined_exploitabilities.pdf")
    plt.show()
    plt.close('all')


if __name__ == '__main__':
    main(parser.parse_args())
