#!/usr/bin/env python3
"""A script that combines exploitabilities of different versions of runs into one file.

Usage:
    ./scripts/grap_last_exploitabilities.py <starting-path>
"""
import json
import sys
from pathlib import Path
from typing import Any

import matplotlib.pyplot as plt  # type: ignore
import numpy as np

from incomplete_cooperative.run.save import Output
from scripts.find_data_jsons import find_data_jsons
from scripts.plot_base import COLOR_VALUES, NAME_MAP, filter_func


def add_to_plt(data: np.ndarray, labels: list[int], name: str, color: Any, line: str) -> Any:
    """Add data drawing to plot."""
    labels = np.array(labels[1:], float)
    data = data[1:]
    mean = np.mean(data, 1)
    stde = np.std(data, 1)
    plt.yscale('log')
    line = plt.plot(
        labels, mean, color=color, zorder=4, label=name, linestyle=line)[0]
    plt.fill_between(
        labels, mean + stde, mean - stde, color=color, zorder=3, alpha=0.3)
    return line


def sort_graph(x: list[int], y: np.ndarray) -> tuple[list[int], np.ndarray]:
    """Sort graph values."""
    if len(x) < 2:
        return x, y
    sorted_x = sorted(x)
    sorted_y_indices = list(map(lambda z: z[0], sorted(enumerate(x), key=lambda z: z[1])))
    sorted_y = y[sorted_y_indices]
    return sorted_x, sorted_y


def draw_data(data: list[tuple[str, list[int], np.ndarray]], path: Path, title: str) -> None:
    """Save the data to file."""
    plt.grid(zorder=-1, alpha=.3)
    # plt.ylim(bottom=0, top=max(np.max(x) for _, _, x in data))
    plt.xlim((min(min(x) for _, x, _ in data) + 1, max(max(x) for _, x, _ in data)))

    lines = []
    for name, x, y in data:
        if not x:
            continue
        x, y = sort_graph(x, y)
        color, line = COLOR_VALUES[name]
        print(name, np.mean(y, 1))
        lines.append(add_to_plt(y, x, NAME_MAP.get(name, name), color, line))

    best_x = max(map(lambda x: sort_graph(x[1], x[2])[0], data), key=len)
    plt.xticks(best_x[1:], map(lambda x: f"${x}$", best_x[1:]))
    plt.legend(handles=lines)
    plt.title(title)
    plt.xlabel("Number of Players")
    plt.ylabel("$l_1$ Divergence")
    plt.savefig(path)
    plt.close('all')


def gather_data(path: Path, normalize: bool = False) -> list[tuple[str, list[int], np.ndarray]]:
    """Gather data.

    Returns a list of tuples:
        the list of number positions,
        the name,
        the values.
    """
    r: dict[str, tuple[list[int], np.ndarray]] = {}
    for data in find_data_jsons(path):
        with data.open("r") as f:
            data_keys = json.load(f).keys()

        for name in data_keys:
            if not filter_func(name):
                continue
            output = Output.from_file(data, name)
            last_out_data = output.data[-1]
            if normalize:
                last_out_data = last_out_data.copy() / output.avg_data[0]
            else:
                last_out_data = last_out_data.copy()
            number = output.parsed_args.number_of_players
            if name in r.keys() and number in r[name][0]:
                continue
            elif name not in r.keys():
                r[name] = [number], last_out_data.copy().reshape((1, last_out_data.shape[0]))
            else:
                r[name] = r[name][0] + [number], np.vstack((r[name][1], last_out_data))

    return sorted(((k, *v) for k, v in r.items()), key=lambda x: NAME_MAP.get(x[0], x[0]))


def main(path: Path = Path(sys.argv[1]), title: str = sys.argv[2]) -> None:
    """Run the script."""
    data = gather_data(path, normalize=False)
    save_path = path / "combined_last_exploitabilities.pdf"
    draw_data(data, save_path, title)


if __name__ == '__main__':
    main()
