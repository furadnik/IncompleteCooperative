#!/usr/bin/env python3
"""A script that combines exploitabilities of different runs into one file.

Usage:
    ./scripts/exploitability_combiner.py <starting-path>
"""
import json
import os
import sys
from pathlib import Path
from typing import Any

import matplotlib.pyplot as plt  # type: ignore
import numpy as np
import scipy

from incomplete_cooperative.run.save import Output
from scripts.find_data_jsons import find_data_jsons
from scripts.plot_base import (COLOR_VALUES, EXPLOITABILITY, NAME_MAP,
                               filter_func)

DEFALUT_COLOR = list(COLOR_VALUES.values())[0]
COMPARE_TO = os.getenv("COMPARE_TO")
COMPARE_TO_NAME = NAME_MAP.get(COMPARE_TO)


def add_to_plt(data: np.ndarray, name: str, color: Any, style: str) -> Any:
    """Add data drawing to plot."""
    data_length = data.shape[0]
    mean = np.mean(data, 1)
    stde = scipy.stats.sem(data, 1)
    line = plt.plot(
        range(data_length), mean, color=color, zorder=4, label=name, linestyle=style)[0]
    plt.fill_between(
        range(data_length), mean + stde, mean - stde, color=color, zorder=3, alpha=0.3)
    return line


def apply_compare_to(datas: np.ndarray, codes: np.ndarray) -> np.ndarray:
    """Apply a 'compare to' view to the data."""
    assert COMPARE_TO is not None
    assert COMPARE_TO in codes
    compared_data = next(data for data, code in zip(datas, codes) if code == COMPARE_TO)
    assert all(data.shape[0] == compared_data.shape[0] for data in datas)

    mean = np.mean(compared_data, 1)
    nonzero = mean > 0
    return [data[nonzero] / mean[nonzero][:, None] for data in datas]


def draw_combined_graph(codes_outputs: list[tuple[str, Output]], output_path: Path, title: str) -> None:
    """Draw data into a combined graph."""
    # perform sorting by name
    names_codes_outputs = sorted((NAME_MAP.get(code, code), code, output) for code, output in codes_outputs)
    names = [name for name, _, _ in names_codes_outputs]
    codes = [code for _, code, _ in names_codes_outputs]
    outputs = [output for _, _, output in names_codes_outputs]
    datas = [output.data for output in outputs]

    if COMPARE_TO:
        datas = apply_compare_to(datas, codes)

    maximum_exploitability = max(np.max(data) for data in datas)
    maximum_episode_length = max(data.shape[0] for data in datas) - 1

    # plot setup
    plt.grid(zorder=-1, alpha=.3)
    plt.ylim(bottom=0, top=maximum_exploitability)
    plt.xlim((0, maximum_episode_length))

    colors_styles = (COLOR_VALUES.get(code, DEFALUT_COLOR) for code in codes)
    lines = [add_to_plt(data, name, color, style)
             for name, data, code, (color, style) in zip(names, datas, codes, colors_styles)
             if code != COMPARE_TO]

    plt.legend(handles=lines)
    plt.title(title, family="monospace")
    plt.xlabel("Budget")
    if not COMPARE_TO:
        plt.ylabel(EXPLOITABILITY)
    else:
        plt.ylabel(f"{EXPLOITABILITY} compared to {COMPARE_TO_NAME}")
    plt.savefig(output_path)
    plt.close('all')


def main(path: Path = Path(sys.argv[1]), title: str = sys.argv[2]) -> None:
    """Run the script."""
    for data in find_data_jsons(path):
        save_path = data.parent / "combined_exploitabilities.pdf"
        with data.open("r") as f:
            outputs_raw = json.load(f)

        # a tuple (name, exploitabilities) of all runs (possibly filtered by the specified names in arg 3)
        codes_outputs = [(code, Output.from_json(raw_data))
                         for code, raw_data in outputs_raw.items() if filter_func(code)]
        print(*(code for code, _ in codes_outputs))
        draw_combined_graph(codes_outputs, save_path, title)


if __name__ == '__main__':
    main()
