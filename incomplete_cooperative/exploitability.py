"""Compute exploitability and C-gain."""
from __future__ import annotations

from typing import Iterable

import numpy as np

from .coalitions import Coalition, all_coalitions, grand_coalition
from .protocols import IncompleteGame, Player, Value, Values
from .shapley import compute_shapley_value_for_player


class MaxGainGame:
    """The game that maximises gain for a given player."""

    def __init__(self, game: IncompleteGame, player: Player) -> None:
        """Save the game and player."""
        self._game = game
        self.player = player
        coalitions_with_player = (1 if player in coalition else 0 for coalition in all_coalitions(game))
        self._player_mask = np.fromiter(coalitions_with_player, bool, 2**self.number_of_players)

    @property
    def number_of_players(self) -> int:
        """Get number of players."""
        return self._game.number_of_players

    def get_values(self, coalitions: Iterable[Coalition] | None = None) -> Values:
        """Get values for (some) coalitions the game. Defaults to all coalitions."""
        upper_bounds = self._game.get_upper_bounds() * self._player_mask
        lower_bounds = self._game.get_lower_bounds() * (1 - self._player_mask)
        bounds = upper_bounds + lower_bounds
        return bounds if coalitions is None else bounds[list(map(lambda x: x.id, coalitions))]

    def get_value(self, coalition: Coalition) -> Value:
        """Get value for a specific coalition."""
        return self._game.get_upper_bound(coalition) if self.player in coalition \
            else self._game.get_lower_bound(coalition)

    def copy(self) -> MaxGainGame:  # pragma: no cover
        """Get a copy of the game."""
        raise NotImplementedError("Cannot copy MaxGainGames.")


def compute_exploitability(game: IncompleteGame) -> Value:
    """Compute the exploitability of the game."""
    max_gain_games = (MaxGainGame(game, player) for player in range(game.number_of_players))
    max_shapley_values = map(lambda game: compute_shapley_value_for_player(game.player, game),
                             max_gain_games)
    return sum(max_shapley_values) - game.get_value(grand_coalition(game))
